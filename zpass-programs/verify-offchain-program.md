# Verify offchain program

## Example program

<pre><code>```leo
<strong>// The 'verify_offchain' program.
</strong><strong>program verify_offchain.aleo {
</strong>    struct Credentials {
        issuer: address,
        subject: address,
        dob: u32,
        nationality: field,
        expiry: u32
    }

    transition verify(
        sig: signature,
        public issuer: address,
        dob: u32,
        nationality: field,
        expiry: u32
    ) {
        let creds: Credentials = Credentials {
            issuer: issuer,
            subject: self.caller,
            dob: dob,
            nationality: nationality,
            expiry: expiry
        };
        let res: bool = signature::verify(sig, creds.issuer, Poseidon2::hash_to_field(creds));
        assert_eq(res, true);
    }
}
```
</code></pre>

The program above demonstrates an example implementation of an offchain verification mechanism using zPass. The `Credentials` can be adjusted to contain any value type supported on Aleo, providing flexibility for various use cases.

In the `verify`transition function, the program takes two parameters: the `signature` and the `values` within the `Credentials`. The `signature` is generated by the trusted issuer responsible for attesting to the user's credentials. While Zero-Knowledge Proofs (ZKPs) excel at verifying the correctness of computations or private data without revealing the underlying data, they lack the ability to authenticate the data itself. To overcome this limitation, digital signatures from trusted parties are used to ensure the authenticity of the data. These signatures provide a cryptographic guarantee that the data originates from a legitimate and trusted source, thereby complementing the privacy-preserving and verification strengths of ZKPs.

Within the `verify` transition function, the program reconstructs the hash of the credentials using `self.caller` as the subject, ensuring that the caller is indeed the user. It then asserts that the user’s credentials have been signed by the trusted issuer. To enable transparent verification, the issuer's identity is made publicly visible, allowing the verifier to confirm that the signature originates from a trusted party.

If the program executes successfully, the user can generate a Zero-Knowledge proof, which can be passed to the verifier. This approach allows the verifier to confirm the validity of the proof without requiring access to the user’s private credentials, maintaining privacy while ensuring security and authenticity.
